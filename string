串    定义 其实就是字符串

      分类 零个字符的串叫做空串（null string）
           空格串 仅含有空格且空格数大于0的串
           子串 串中任意个数的连续（划重点）字符组成的子序列称为该串的子串
           
      串的比较 本质上，串的比较通过组成串的字符对应编码来进行，字符的编码指的是字符在对应字符集中的序号
               计算机中使用的是标准的ASCII编码，这个编码本质上都是7位二进制数，可表示128个字符（后来扩展至8位，可表示256位）
               后来又有了Unicode编码，用16位二进制数，可表示pow（2，16）个字符，能容纳全世界的语言与文字，为了与ASCII码兼容
               它的前256个字符与ASCII完全相同
               
               sn<tm的定义 对于字符串sn，tm
                           1.n<m，且si=ti（i=1，2，3，....，n） 
                           2.存在某个k<=min(n,m),使得si=ti(i=1,2,3,....,k),sk<tk
               sn=tm的定义 当n=m且si=ti(i=1,2,3,...,n）时sn=tm
               
     
      串的存储结构(书本内容讲的十分简洁) 顺序存储结构 用数组实现，有的语言将串的长度保存在数组下标0的位置，有的语言用字符'\0'表示串的终结（这时想要知道串长度就需要遍历） 
                                         链式存储结构 用链表实现，只是一个结点存储一个字符就十分浪费，可以一个结点存放多个字符，若结点未满，用字符‘#’补全。但是这样会影响串的处理效率
                                         链式结构除了在连接串时有一定方便，总的来说，方便性与性能都不如顺序存储结构
      
      朴素的模式匹配算法 模式匹配就是指定位字串。朴素方法是指从规定的开头开始比，一旦有所不同，就退出，又从下一位开始比，直到找到或者确定不存在
  
                         操作说明 在主串s中第pos个字符之后寻找子串t，找到返回其下标，否则返回0（说明pos>=1）
                         int index(string s,string t,int pos)
                         {
                             int i,j,lenT=t.length(),lenS=s.length();
                             for(i=pos;i<=lenS-lenT;i++)
                             {
                                 for(j=0;j<lent;j++)    这段代码实现了从串下标i处往后取长度为lenT的字串的基本操作subString
                                     if(s[i+j] != t[j]) break;  这段代码实现了比较两个字符串是否相等的操作strCompare
                                 if(j==lenT) return i;
                             }
                             return 0;
                         }
                         
                         计算机处理的本质上都是二进制数，如果遇到0000000000000000000000000000000001（共五十位数）中寻找子串0000000001（共十位数）
                         那么循环要进行（40+1）*10次，所以上述算法时间复杂度位O[(n-m+1)*m].太低效了
     
     KMP模式匹配算法
     
     
                      
      
             
   
